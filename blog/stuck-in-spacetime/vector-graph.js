// https://vector-graph.com/
const detectDarkmode=()=>"undefined"!=typeof window&&window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,parseOptions=t=>[...t].reduce(((t,{name:e,nodeValue:r})=>{let n=r;return/^[\-0-9\.]+$/.test(n)&&(n=+n),/^[\-0-9\.]+\,\s*[\-0-9\.]+$/.test(n)&&(n=n.split(",").map((t=>+t))),/^([\-0-9\.]+\,\s*[\-0-9\.]+\;)+[\-0-9\.]+\,\s*[\-0-9\.]+$/.test(n)&&(n=n.split(";").map((t=>t.split(",").map((t=>+t))))),""===n&&(n=!0),"true"===n&&(n=!0),"false"===n&&(n=!1),{...t,[e]:n}}),{}),drawUnits=({from:t=0,to:e,axis:r,color:n,size:o},a)=>{const{xScale:l,yScale:i,colors:s}=a;n||(n=s.dark);let c="",d=0;o<1&&(d=1),o<.1&&(d=2),o<.01&&(d=3);for(let s=t=o*Math.ceil(t/o);s<e;s+=o)if("x"===r){const t=s,e=s.toFixed(d);c+=drawLine({from:[t,0],to:[t,-5/i],width:1.5,color:n},a),c+=drawLabel({text:e,x:t,y:-14/i,color:n,size:"tiny"},a)}else{const t=s,e=s.toFixed(d);c+=drawLine({from:[0,t],to:[-5/l,t],width:1.5,color:n},a),c+=drawLabel({text:e,x:-12/i,y:t,color:n,size:"tiny",width:20},a)}return c},drawGrid=({size:t,color:e,fill:r},n)=>{const{width:o,height:a,x:l,y:i,xScale:s,yScale:c}=n,d=`grid-${t}-${e}-${r}-${o}-${a}-${s}-${c}`,h=t*s,x=t*c,w=-l[0]*s,y=-i[0]*s;return t?`\n    <defs>\n      <pattern id="${d}" width="${h}" height="${x}" patternUnits="userSpaceOnUse" patternTransform="translate(${w}, ${y})">\n        <path\n          d="M 0 0 L 0 ${h} ${x} ${h} ${x} 0 0 0"\n          fill="${r}"\n          stroke="${e}"\n          stroke-width="0.5"\n        />\n      </pattern>\n    </defs>\n    <rect width="${o}" height="${a}" fill="url(#${d})" style="${`\n    transform: scaleY(-1);\n    transform-origin: 0 ${a/2}px;\n  `}" />\n  `:""};let globalId=0;const sizes={tiny:8,small:8,normal:10,large:12},fontSizes={tiny:12,small:12,normal:16,large:20},strokeSizes={tiny:0,small:1,normal:1.75,large:2},drawText=({text:t,x:e,y:r,color:n,size:o,width:a},l)=>{const{height:i,xScale:s,yScale:c,colors:d,pad:h,...x}=l;if(!t)return"";o||(o="normal"),a||(a=("m"+t).length*sizes[o]),n||(n=d.black);return`\n    <text x="${Math.max(1-h+a/2,s*(e-x.x[0]))}" y="${i-c*(r-x.y[0])+1}" width="${a}" fill="${n}" style="${"dominant-baseline: middle; text-anchor: middle; font: "+`normal ${fontSizes[o]}px sans-serif`}">\n      ${t}\n    </text>\n  `},drawLabel=({text:t,x:e,y:r,size:n,width:o,height:a,color:l},i)=>{const{xScale:s,yScale:c,colors:d,pad:h}=i;if(!t)return"";n||(n="normal"),o||(o=("m"+t).length*sizes[n]),a||(a=2.1*sizes[n]),l||(l=d.black);return`\n    <rect\n      x="${Math.max(1-h,s*(e-i.x[0])-o/2)}"\n      y="${i.height-c*(r-i.y[0])-a/2}"\n      width="${o}"\n      height="${a}"\n      fill="${d.light}"\n      stroke="${l}"\n      stroke-width="${strokeSizes[n]}"\n      rx="5"\n    />\n    ${drawText({text:t,x:e,y:r,color:l,size:n,width:o},i)}\n  `},drawPoint=({x:t=0,y:e=0,label:r,color:n,axis:o},a)=>{const{height:l,xScale:i,yScale:s,colors:c}=a;n||(n=c.black);return`\n    <circle cx=${(t-a.x[0])*i} cy=${l-(e-a.y[0])*s} r="4" fill="${n}" />\n    ${drawLabel({text:r,color:n,x:t,y:e+20/s},a)}\n    ${o?drawCoordinates({x:t,y:e,axis:o,color:n},a):""}\n  `},drawPolygon=({points:t,color:e,angles:r},n)=>{const o=[];e=e||n.colors.black;for(let r=0;r<t.length;r++){const a=t[r],l=t[(r+1)%t.length];o.push(drawLine({from:a,to:l,color:e},n))}if(r){"string"==typeof r&&(r=r.split(","));for(let a=0;a<t.length;a++){const l=t[a],i=t[(a+1)%t.length],s=t[(t.length+a-1)%t.length],c=Math.sqrt((l[0]-i[0])**2+(l[1]-i[1])**2),d=[i[0]-l[0],i[1]-l[1]],h=[l[0]-s[0],l[1]-s[1]],x=180+180*Math.atan2(h[1],h[0])/Math.PI,w=180*Math.atan2(d[1],d[0])/Math.PI,y=c/3;o.push(drawAngle({x:l[0],y:l[1],label:r[a],from:x,to:w,color:e,radius:y},n))}}return o.join("")},drawLine=({to:t,from:e,label:r,color:n,width:o,dashed:a},l)=>{const{height:i,x:s,y:c,xScale:d,yScale:h,colors:x}=l;e||(e=[0,0]),n||(n=x.black),o||(o=1.75),a&&(a="5,3");const w=d*(e[0]-s[0]),y=i-h*(e[1]-c[0]),$=(t[0]-s[0])*d,p=i-(t[1]-c[0])*h,f=(t[0]+e[0])/2,u=(t[1]+e[1])/2;return`\n    <line\n      x1="${w}"\n      y1="${y}"\n      x2="${$}"\n      y2="${p}"\n      stroke="${n}"\n      stroke-width="${o}"\n      stroke-dasharray="${a}"\n    />\n    ${drawLabel({text:r,color:n,x:f,y:u},l)}\n  `},drawCircle=({x:t=0,y:e=0,radius:r,label:n,color:o,width:a},l)=>{const{height:i,xScale:s,yScale:c,colors:d}=l;o||(o=d.black),a||(a=2);return`\n    <ellipse\n      cx="${(t-l.x[0])*s}"\n      cy="${i-(e-l.y[0])*c}"\n      rx="${r*s}"\n      ry="${r*c}"\n      fill="none"\n      stroke="${o}"\n      stroke-width="${a}"\n      path-length="1px"\n      />\n      ${n?drawLabel({text:n,x:t,y:e,color:o},l):""}\n  `};function toEuclidian(t,e,r,n){return[t+r*Math.cos(n),e+r*Math.sin(n)]}function drawArc(t,e,r,n,o){const a=-n*Math.PI/180,l=-o*Math.PI/180,i=o-n<=180?"0":"1",[s,c]=toEuclidian(t,e,r,a),[d,h]=toEuclidian(t,e,r,l);return`M ${s} ${c} A ${r} ${r} 0 ${i} 0 ${d} ${h}`}const drawAngle=({x:t=0,y:e=0,from:r,to:n,radius:o,label:a,color:l,size:i,dashed:s},c)=>{const{height:d,xScale:h,yScale:x,colors:w}=c;r||(r=0),r>n&&([n,r]=[r,n]),r=(r+360)%360,n=(n+360)%360,o||(o=c.x[1]/3),l||(l=w.black),i||(i="small"),(s||void 0===s)&&(s="5,3");let y=(r+n)*Math.PI/360;Math.abs(n-r)>180&&(y+=Math.PI);const $=n>=180,p=r>=180,f=Math.tan(n*Math.PI/180);n=180*Math.atan2(f*x,h)/Math.PI;const u=Math.tan(r*Math.PI/180);r=((r=180*Math.atan2(u*x,h)/Math.PI)+360)%360,n=(n+360)%360,$&&n<180&&(n+=180),p&&r<180&&(r+=180),!$&&n>180&&(n-=180),!p&&r>180&&(r-=180),r=Math.round((r+360)%360),n=Math.round((n+360)%360);const g=h*(t-c.x[0]),m=d-x*(e-c.y[0]),M=t+o*Math.cos(y),b=e+o*Math.sin(y);return`\n    <path\n      fill="none"\n      stroke="${l}"\n      stroke-width="1"\n      stroke-dasharray="${s}"\n      d="${drawArc(g,m,o*h,r,n)}"\n    />\n    ${drawLabel({text:a,x:M,y:b,size:i,color:l},c)}\n  `},drawCoordinates=({x:t,y:e,axis:r,color:n},o)=>{const{xScale:a,yScale:l}=o;r&&!0!==r||(r=[t,e]),"string"==typeof r&&(r=r.split(","));const i="small";return[drawLine({from:[t,0],to:[t,e],width:1,dashed:true,color:n},o),drawLine({from:[0,e],to:[t,e],width:1,dashed:true,color:n},o),drawLabel({text:r[0],x:t,y:-12/l,color:n,size:i},o),drawLabel({text:r[1],x:-12/a,y:e,color:n,size:i},o)].join("")},drawVector=({from:t,to:e,label:r,axis:n,color:o},a)=>{const{height:l,x:i,y:s,xScale:c,yScale:d,colors:h}=a,x=globalId++;t||(t=[0,0]),o||(o=h.black);const w=c*(t[0]-i[0]),y=l-d*(t[1]-s[0]),$=[(e[0]-t[0])*c,(e[1]-t[1])*d],p=Math.sqrt($[0]**2+$[1]**2),f=Math.atan2($[1],$[0]),u=p-20,g=w+u*Math.cos(f),m=y-u*Math.sin(f),M=(e[0]+t[0])/2,b=(e[1]+t[1])/2;return`\n    <defs>\n      <marker\n        id="h-${x}"\n        markerWidth="10"\n        markerHeight="5"\n        refY="2.5"\n        orient="auto"\n      >\n        <polygon points="0 0, 10 2.5, 0 5" fill="${o}" />\n      </marker>\n    </defs>\n    <line\n      x1="${w}"\n      y1="${y}"\n      x2="${g}"\n      y2="${m}"\n      stroke="${o}"\n      stroke-width="2"\n      marker-end="url(#h-${x})"\n    />\n    ${drawLabel({text:r,color:o,x:M,y:b},a)}\n    ${n?drawCoordinates({x:e[0],y:e[1],axis:n,color:o},a):""}\n  `},defaultOptions={width:200,height:200,x:[0,10],y:[0,10],grid:1,dark:"undefined"!=typeof window&&window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,pad:30,axis:"x,y"}; function graph(t){const e=(new DOMParser).parseFromString(t,"text/html");let{width:r,height:n,x:o,y:a,labels:l,units:i,grid:s,dark:c,axis:d,pad:h}={...defaultOptions,...parseOptions(e.querySelector("vector-graph").attributes)};"number"==typeof o&&(o=[0,o]),"number"==typeof a&&(a=[0,a]),"string"==typeof d&&(d=d.split(",")),!0===s&&(s=1);const x=r/(o[1]-o[0]),w=n/(a[1]-a[0]),y={light:c?"#000":"#fff",gray:c?"#666":"#ccc",dark:"#aaa",black:c?"#fff":"#000"},$=document.createElementNS("http://www.w3.org/2000/svg","svg");$.setAttribute("width",r),$.setAttribute("height",n),$.setAttribute("viewBox",`${-h} ${.6*-h} ${r+1.6*h} ${n+1.6*h}`),$.setAttribute("xmlns","http://www.w3.org/2000/svg"),$.style.background=y.light,$.style.borderRadius="8px";const p=[];if(s&&p.push({type:"grid",color:y.gray,fill:y.light,size:s}),d){const t=y.dark;p.push({type:"vector",color:t,to:[o[1],0]},{type:"vector",color:t,to:[0,a[1]]},{type:"text",text:d[0],color:t,x:o[1],y:12/w},{type:"text",text:d[1],color:t,x:12/x,y:a[1]})}i&&p.push({type:"units",size:s||1,from:o[0],to:o[1],axis:"x"},{type:"units",size:s||1,from:a[0],to:a[1],axis:"y"}),p.push(...[...e.querySelector("vector-graph").children].map((t=>({type:t.nodeName.toLowerCase(),...parseOptions(t.attributes)}))));const f={width:r,height:n,x:o,y:a,xScale:x,yScale:w,colors:y,pad:h};return p.filter(Boolean).forEach((({type:t,...e})=>{"units"===t&&($.innerHTML+=drawUnits(e,f)),"grid"===t&&($.innerHTML+=drawGrid(e,f)),"vector"===t&&($.innerHTML+=drawVector(e,f)),"line"===t&&($.innerHTML+=drawLine(e,f)),"circle"===t&&($.innerHTML+=drawCircle(e,f)),"polygon"===t&&($.innerHTML+=drawPolygon(e,f)),"angle"===t&&($.innerHTML+=drawAngle(e,f)),"point"===t&&($.innerHTML+=drawPoint(e,f)),"label"===t&&($.innerHTML+=drawLabel(e,f)),"text"===t&&($.innerHTML+=drawText(e,f))})),$.outerHTML}if("undefined"!=typeof HTMLElement){class t extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML=graph(this.outerHTML)}}customElements.define("vector-graph",t)}
//# sourceMappingURL=/sm/1fc431859f3eb0decc9950558af48f4fa05dbe2ab58de4203f799a4aad450851.map
